# How to Implement C/C++ FFI in Rust Embedded Projects

The idea of this document is to provide a guide on how to implement C/C++ Foreign Function Interface (FFI) in Rust
embedded projects. This is useful when you need to integrate existing C/C++ code or libraries into your Rust embedded
application.  

Using this approach, you can use tools like STM32CubeMX to generate C/C++ code for your STM32 microcontroller
initialization and peripherals, and then integrate that code into your Rust project using FFI to save time implementing
this initialization code in Rust.  

## Setup C/C++ FFI in Rust Embedded Projects

First generate the project's C/C++ files using STM32CubeMX or any other tool you prefer in the `cpp_src\` directory.    
Then, follow these steps to set up the C/C++ FFI in your Rust embedded project:

- In the `config.toml` file, replace the linker script with the one generated by STM32CubeMX or your tool of choice.
```toml
rustflags = [
  "-C", "link-arg=-T<LINKER SCRIPT>" # Linker script
    # .... Other flags 
]
```
- Uncomment the external linker in the config.toml file:
```toml
[target.thumbv7em-none-eabihf]
linker = "arm-none-eabi-ld" # Uncomment if you want to use a custom linker
```
- Install the cross-compilation toolchain for your target architecture, for example, arm-none-eabi toolchain.
  **Note:** Make sure you have the correct toolchain installed for your target architecture and **it is included in the Path**.
- Add cc crate to your [build-dependencies] in the `Cargo.toml` file:
```toml
[build-dependencies]
cc = "1.2"  # For building C/C++ code if needed
```
- Create a `build.rs` file in the root of your project *(outside /src or /cpp_src)*, which will be used to compile the C/C++ code by cc crate.
```rust
```

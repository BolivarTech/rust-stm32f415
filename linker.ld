/*
 * Linker script for STM32F415 microcontroller
 * This script defines memory regions and sections for the STM32F415 device.
 * It specifies where code, data, and other sections should be placed in memory.
 */

/* Define the entry point for the program */
ENTRY(reset_handler)

/* Specify the memory areas */
MEMORY
{
    RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 128K
    CCMRAM (xrw)      : ORIGIN = 0x10000000, LENGTH = 64K
    FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 1024K
}

/* Stack region at the top of RAM */
_start_of_stack = ORIGIN(RAM) + LENGTH(RAM);
_min_stack_size = 0x400;  /* Fixed stack size in bytes, use _min_ for convention */

/* Heap region just below the stack */
_min_heap_size =  0x400;  /* Fixed heap size in bytes, use _min_ for convention */
_heap_start = ORIGIN(RAM) + LENGTH(RAM) - _min_stack_size - _min_heap_size;
_heap_end   = ORIGIN(RAM) + LENGTH(RAM) - _min_stack_size;

/*
 * SECTIONS
 * SECTIONS command in a linker script specifies where each section
 * (e.g., .text, .data, .bss) should be placed in memory.
*/

SECTIONS
{
    /*
    1. Defines where each program section is placed in the microcontroller's memory.

    2. The linker assigns addresses based on the SECTIONS command,
         creating an ELF file with exact memory locations.
        For example , if FLASH starts at 0x08000000 and the .text section is placed in FLASH,
        the linker will assign address starting frm 0x08000000 for the .text section.

    3. The ELF file guides the programming tool to correctly place the sections in the microcontroller's memory,
          ensuring proper execution of the code

    */

    .text :
    {
        /* here you should collect all executable code */
        . = ORIGIN(FLASH);
        LONG(_start_of_stack); /* Reserve space for the stack pointer at the start of FLASH */
        KEEP(*(.isr_vector)); /* Keep the interrupt vector table at the start of the .text section */
        /* Collect all sections that contain executable code
            from the object files and libraries. */
        *(.text)
        *(.text*)
         . = ALIGN(4);
    } > FLASH


  /* Constant data will go into FLASH */
   .rodata :
   {
         . = ALIGN(4);
        *(.rodata)
        *(.rodata*)
         . = ALIGN(4);
   } > FLASH


   /* Initialized data will be in FLASH and it will also be in RAM during runtime*/
   .data :
   {
        _sidata = LOADADDR(.data); /* This returns the FLASH Load Memory Address (LMA) */
         . = ALIGN(4);
        _sdata = .; /* start of data section in RAM Virtual Memory Address (VMA) */
        *(.data)
        *(.data*)
         . = ALIGN(4);
        _edata = .;
   } > RAM AT> FLASH


   /* un-initialized data will be RAM */
   .bss :
   {
         . = ALIGN(4);
        _sbss = .;  /* start of bss section in RAM (VMA) */
        *(.bss)
        *(.bss*)
         . = ALIGN(4);
        _ebss = .;
   } > RAM

   /* If the linker script can fit this section in RAM, it will throw an error. */
   .ram_usage_check :
   {
      . = ALIGN(8);
      . = . + _min_stack_size;
      . = . + _min_heap_size;
      . = ALIGN(8);
      _eram_usage_check = .; /* end of RAM usage check section */
   } > RAM

    /* Fill remain RAM with zero */
    .fill_ram :
    {
        /* Starting from BSS' end, fill the rest with zeros */
        . = ALIGN(4);
        __fill_start__ = .;
        . = ORIGIN(RAM) + LENGTH(RAM) - _min_stack_size;
        . = ALIGN(4);
        __fill_end__ = .;
    } > RAM

}

/* Include the device-specific linker script generated by svd-vector-gen */
INCLUDE "device_STM32F415.x"
